\chapter{Metodología}

\textbf{Buscamos describir cómo abordamos el desarrollo del problema y su solución}.
Leyendo este capítulo el lector conocerá la metodología que empleamos al desarrollar este
proyecto.

Es inmensamente doloroso el poco tiempo que vivimos, pero es que es más doloroso dedicar
nuestro tiempo a tareas que no benefician a aquellos entes a los cuales queremos aportar
valor.
A lo largo de este Trabajo de Fin de Grado exponemos diversos métodos para minimizar
el tiempo invertido en tareas sin valor \textbf{para nuestro propósito}.\footnote{%
    No es lo mismo pilotar un avión tetrarreactor Airbus A380,
    un avión de negocios Gulfstream G800 que una avioneta Cessna 172.
}

Nos servimos de distintos métodos para descubrir, esclarecer y categorizar el conocimiento que necesitamos
para desarrollar un sistema informático: correcta identificación del problema a resolver,
mejor solución posible teniendo en cuenta el entorno en el que se utilizará,
y formulación de la solución de este en términos de datos objetivos acerca de cómo debe de
funcionar un sistema.

\section{Cuestiones previas}

Exponemos información complementaria a las ideas de las secciones de este capítulo.

\subsection{Definiciones}

Utilizamos determinadas acepciones definidas por \cite{RAE_DLE}.

Entendemos el \textbf{arte} como la ``capacidad, habilidad para hacer algo'' y como
el ``conjunto de preceptos y reglas necesarios para hacer algo''.

Entendemos por \textbf{técnica} como aquello ``perteneciente o relativo a las
aplicaciones de las ciencias y de las artes''.

Entendemos por \textbf{método} como ``procedimiento que se sigue en las ciencias
para hallar la verdad y enseñarla.''

Entendemos por \textbf{metodología} el ``conjunto de métodos que se siguen en una investigación
científica o en una exposición doctrinal''.

Entendemos por \textbf{tecnología} como el ``conjunto de teorías y de técnicas que permiten el
aprovechamiento práctico del conocimiento científico''.

Entendemos por \textbf{herramienta} como un ``instrumento que sirve para hacer algo o
conseguir un fin''.

\subsection{La importancia del método}

Los cirujanos, sujetos cognoscentes, operan mediante su cuerpo y herramientas a los seres
vivos para curar, restablecer, aliviar, mejorar o embellecer partes de un cuerpo de
un ser vivo. En este proceso utilizan su conocimiento de las tecnologías pertinentes.
De una forma ordenada y deliberada realizan el procedimiento que consideran adecuado para
lograr su objetivo.

Cuando investigan buscan esclarecer la realidad que se les presenta. Descubren, aclaran y
categorizan.

Según el Diccionario panhispánico del español jurídico, a la ingeniería se la define
de forma general como sigue.

\begin{quote}
    \textit{
    ``Conjunto de conocimientos y técnicas científicas y empíricas aplicadas a la invención,
    el diseño, el desarrollo, la construcción, el mantenimiento y el perfeccionamiento
    de tecnologías, estructuras, máquinas, herramientas, sistemas, materiales y procesos
    para la resolución de problemas prácticos''.
    }
\end{quote}

Sabemos empíricamente que nuestra capacidad para lidiar con la complejidad de forma exacta
es limitada. Además, nuestros procesos, influenciados por el conocimiento que almacenamos (y que recuperamos
principalmente cuando se da un determinado contexto que \textit{activa} este conocimiento),
\textit{siguen un único hilo racional}. Sabemos que \textbf{dadas unas premisas}, existen \textbf{técnicas
no rigurosas} que suelen ser efectivas a la hora de buscar soluciones. Conocemos qué caracteriza
a aquellos proyectos correctos, funcionales, profesionales y de calidad.

Un método por sí solo no tiene capacidad para operar la realidad. Pero nosotros podemos hacerlo.
Mediante nuestro criterio, moldeado por nuestra experiencia, seleccionamos qué queremos trabajar,
y cómo lo haremos\cite[Distinción entre método y metodología]{MetodoUNAM}.\footnote{%
Partiendo de esta definición y de las ideas de Bueno \cite{TeoríaDelCierreCategorial} exponemos
la siguiente tesis.
Un ingeniero opera la realidad con un propósito utilitario. No casualmente sino deliberadamente.
Lo hace por medio de \textit{``[...] tecnologías, estructuras, máquinas, [...]''}.
Por medio de materia y forma opera la realidad. Y operando la realidad modifica la materia y
la forma. De forma deliberada toma decisiones para su propósito. Maximiza la
efectividad de su solución para su propósito dados sus recursos materiales y de forma.
Busca mejorar la forma.
}
 Seguir un buen método para unas determinadas circunstancias nos puede permitir maximizar la
calidad de un producto. Su estructura y atomicidad potencia nuestras capacidades intelectuales
(lo que en el anterior párrafo podría verse como una limitación).
Gracias a que desglosa todas aquellas tareas y productos que podrían interesar desarrollar
en un producto de calidad es más difícil que se nos olviden, más cuando tenemos poca experiencia
o no tenemos todo memorizado.

\subsection{Ágil no es sinónimo de incompletud}

Existen empresas e individuales que se dedican a vender información y formación a otras empresas
o individuales. Es el caso de Robert C. Martin con su empresa Clean Coders, LLC. El caso de 
Ken Schwaber con scrum.org. Es el caso de Kent Beck con sus conferencias y libros. Es el caso
de Andy Hunt y Dave Thomas, \textit{los programadores pragmáticos}.

Estas y otras personas, las cuales se promulgan \textit{líderes} en sus respectivas metodologías,
se reúnen en febrero de 2001 en un resort de ski para encontrar un nexo en común
de sus acercamientos a la hora de desarrollar sistemas informáticos. Según se explica, este evento
se empieza a cocinar en una quedada de defensores del \textit{Extreme Programming}.
\textbf{Y agrupa a aquellos representantes de metodologías que en un principio 
Martin bautiza como \textit{ligeras}}.
\cite{HistoriaManifiestoAgilJim} \cite[Snowbird]{AgileBackToBasics}

El manifiesto ágil \cite{ManifiestoAgil} surge de este encuentro. Expone las siguientes ideas.

\begin{quote}
    \itshape{
    ``We are uncovering better ways of developing
    software by doing it and helping others do it.
    Through this work we have come to value:
    
    \textbf{Individuals and interactions} over processes and tools.

    \textbf{Working software} over comprehensive documentation.

    \textbf{Customer collaboration} over contract negotiation.

    \textbf{Responding to change} over following a plan.
    
    That is, while there is value in the items on
    the right, we value the items on the left more.''
    }
\end{quote}

Según documentan las fuentes, firmantes del manifiesto ágil \cite{ManifiestoAgil}, 
escriben el texto como contraposición a lo que observan en ciertas compañías a la
hora de desarrollar software. Dicen, rehúsan de los procedimientos sin sentido,
a los procedimientos sin un por qué. Alertan de que definitivamente dejarán de ser
compatibles con la incipiente modernización del mercado (expansión del comercio en
línea, compañías en línea, compañías web, etc). \cite{HistoriaManifiestoAgilJim}

Dicen que llegan a estas conclusiones a partir de su experiencia \cite{HistoriaManifiestoAgilJim}
y personalmente añadiría, \textit{y teniendo como objetivo la calidad del producto}.

El manifiesto es vago y no es exhaustivo, pero en ningún lugar se habla de no utilizar
procesos o herramientas.
No se desprestigia a la documentación. No se le resta valor a la negociación
de un contrato. No busca no seguir un plan.

\section{Uso de un repositorio}

Entendemos un repositorio como un lugar en el que almacenamos información.
En nuestro caso, información digital. Principalmente documentación, recursos
gráficos y código.

Utilizamos un único repositorio para facilitar el asegurar la coherencia
de los datos, mejorar la cohesión y organización de estos y facilitar su
recuperación.

En el repositorio únicamente almacenamos estados correctos del proyecto. No
almacenamos información que no sea relevante, como las que generan automáticamente
algunas herramientas. Siempre reflexionamos antes de realizar \textit{vendoring}%
\footnote{\textit{Vendoring} consiste en hacer copias de software de terceros en
nuestro propio repositorio. Por ejemplo, no suele tener sentido para una dependencia en
un paquete de \texttt{npm}. Se suele evitar hacer esto porque los software de control
de versiones para software no se suelen llevar bien con los binarios y porque que el código será
más difícil de actualizar.}.

\subsection{Seguimiento de cambios sobre el repositorio}

Sabemos que si a cada modificación que hacemos en el repositorio anotamos
lo que ha cambiado y por qué lo hemos hecho entonces tenemos distintas ventajas.

\begin{enumerate}
    \item Sabiendo la razón por la que se realiza un cambio ayudamos a entender
          el cambio a un tercero, o a nuestro yo del futuro.
    \item Podemos visitar estados anteriores del proyecto.
    \item Cuando liberamos una versión podemos saber qué ha cambiado desde la última
          versión, pudiendo ofrecer al cliente un histórico de cambios.
\end{enumerate}

Por convención los mensajes que acompañarán a estas \textit{contribuciones} vienen
dados en imperativo y serán claros y concisos, tal y como se propone en \cite[Commit Guidelines]{ProGIT}.

Si además estos cambios son para modificar un único aspecto del repositorio
entonces, además de potenciar los beneficios anteriores, tenemos las siguientes
ventajas entre otras.

\begin{enumerate}
    \item Deshacer cambios es más fácil.
    \item Identificar cambios concretos es más fácil. Por ejemplo, encontrar cuándo se introduce un bug
           es más fácil.
    \item El proceso de fusionar dos repositorios divergentes puede ser mas fácil y cómodo.
    \item La revisión por parte de un tercero, o por nosotros mismos, es mas clara.
    \item Es más fácil encontrar un mensaje descriptivo y conciso que explique qué cambia y por qué.
    \item Nos obliga a trabajar sobre un único aspecto del repositorio, lo que potencia nuestras
          capacidades intelectuales.
\end{enumerate}

Imponemos sendas restricciones en nuestro repositorio.

\subsection{Validez de los datos}

¿Qué determina la validez del repositorio? Su capacidad de despliegue en cualquier
momento de acuerdo a los requisitos que forman parte de los productos que componen
el repositorio.

No contribuimos en aquellos casos en los que no tenemos la certeza anterior.
Automatizamos en aquellos casos en los que estimemos que sea rentable en tiempo
y dinero.

\subsection{Uso de versionado semántico}

Los cambios sobre el repositorio siguen un orden cronológico.
Si un determinado cambio es el último que se hace antes de
liberar los productos que contienen el repositorio (por ejemplo,
cuando alcanzamos un hito) entonces a este cambio le asignamos
un nombre específico.

El nombre que le asignamos tiene que tener la forma \texttt{v[VERSION]},
donde \textit{\texttt{[VERSION]}} tiene la forma \texttt{[MAJOR].[MINOR].[PATCH]} y donde
\textit{\texttt{[MAYOR]}}, \textit{\texttt{[MINOR]}} y \textit{\texttt{[PATCH]}} son números que se
especifican según el esquema de versionado \textit{SemVer 2.0.0} \cite{SemVer}.
Escogemos este esquema de versionado porque es sencillo, bien conocido y se puede
entender de forma intuitiva.

\section{Indagación y esclarecimiento del problema a resolver}

Dialogamos con el cliente, formulamos el problema haciendo uso de las fases de
empatizar y definir del método \textit{Design Thinking} para después, tanto en un análisis
previo como a medida que vamos desarrollando el proyecto, extraer historias de usuario, historias de
desarrollador y \textit{user journeys} de donde obtenemos los objetivos deseados
junto a sus respectivas importancias.
Finalmente sintetizamos esta información en forma de requisitos funcionales y
requisitos no funcionales.

\subsection{Conversaciones con el cliente}

Este primer método lo ideamos una vez el cliente nos comunica brevemente su necesidad.
\textbf{Su principal objetivo es el de recuperar y modelar el problema a resolver}, ya sea en
el análisis previo o como complementario del análisis continuo, pero también busca
otros objetivos como el de transmitir confianza al cliente o el de ayudarnos como empresa a
decidir si esta será una batalla en la que nos gustaría e interesaría participar.

\textbf{El primer paso es que el cliente comunique su necesidad.} Sólo por el hecho de que esta
persona física o jurídica está depositando confianza en nosotros merece el más
adecuado respeto, que se demuestra dejándole el espacio que necesita para exponer
sus ideas. De esta descripción extraemos información verbal y
no verbal que nos ayuda a comprender las circunstancias en que ocurre el potencial
problema a resolver, y en caso de no ser un cliente de confianza o desconocer las
circunstancias en que se desenvuelve el problema, si como empresa nos interesa
ser un proveedor de soluciones para él y su sector.

De una forma atenta \textbf{y crítica} escuchamos y anotamos la información que el
cliente quiere transmitirnos. Si existe algún término que enuncia y desconocemos
o alguna circunstancia que nos describe y que no llegamos a comprender o bien le
interrumpimos o bien anotamos para preguntar más adelante.

\textbf{El segundo paso es identificar la raíz del problema.} Por experiencia sabemos
que las personas tienden a enunciar los problemas en términos de la solución.
Muchas veces aquello que nos solicitan responde a una necesidad subyacente que no
se identifica o, si identificada, no se comunica.

Buscamos dialogando con el cliente y por medio de nuestra propia investigación exponer
el problema eliminando las restricciones innecesarias, buscando aquellas que son
necesarias y, a poder ser, sin omitir aspectos que pudiesen afectar a la arquitectura
de la solución.

Por ejemplo, proponemos borradores rápidos de arquitectura los cuales
nuestro cliente puede analizar de forma crítica, de forma independiente
o por medio del método dialéctico. El interesado desmiente aquellos aspectos
pertinentes y saca a la luz nuevas necesidades y restricciones que no se habían
comunicado.

\textbf{El último paso consiste en formalizar las conversaciones} por medio de las
herramientas que estimemos según las circunstancias\footnote{%
    No utilizaremos las mismas herramientas y documentos para un cliente para el cual
    sabemos por experiencia qué es lo que quiere que para otro que nos exige resolver
    un problema de un sector y aplicación que desconocemos. También variamos según
    la capacitación técnica del cliente en nuestro dominio.
}. De esta forma, por medio de comunicaciones escritas, resolvemos el problema de
sincronizarnos con el cliente.

Por ejemplo, para los productos que desarrollamos en nuestro TFG, sabemos por experiencia
que para nuestros clientes y dado nuestro conocimiento en el sector el punto dulce está
en hacer un único documento en el que describimos hitos a alcanzar en el desarrollo.
Estos hitos los desglosamos en descripciones claras y concisas acerca del comportamiento del software.
A este documento lo llamamos \textbf{Plan de Desarrollo}.

Gracias a este documento el cliente puede darse
cuenta rápidamente de que estamos dedicando tiempo de desarrollo a un aspecto que no le
interesa desarrollar ahora mismo. Porque puede conocer en todo momento el estado del desarrollo.

\subsection{Contexto en el que se desarrolla el problema}

Para poder cuantificar de una aproximada el potencial de proyecto y para, en caso de que el
proyecto nos interese, formular los requisitos desde el punto de vista de los clientes que
interactuarán con nuestro producto, investigamos acerca del contexto que rodea al problema.

Descubrimos quiénes son los usuarios objetivo de nuestros productos y en qué contexto
interactuarían con el sistema.

\subsection{Investigación de los últimos avances (\textit{state-of-the-art})}

Investigamos si existen o no soluciones existentes para el problema. Si las existen,
las evaluamos y estudiamos su enfoque.

\section{Definición del problema a resolver (definición de requisitos)}

Definimos en forma de requisitos funciones y no funcionales cómo debe de comportarse el
sistema. Lo hacemos así porque nuestra experiencia nos dice que suele ser suficiente
para este tipo de proyectos. En caso de esto no fuese suficiente o
que trabajásemos con más gente y el proyecto tuviese un riesgo superior plantearíamos
trabajar con otro tipo de herramientas como son las historias de usuario, de desarrollador
o \textit{user journeys}, por ejemplo.

Buscamos especificar en detalle lo que el sistema informático tiene que hacer, aunque no
cómo tiene que hacerlo. De esta forma no restringimos de forma innecesaria
las posibles soluciones de diseño o de Implementación que podamos encontrar.

Una correcta y completa definición de requisitos nos ayudará a poner en común con nuestro
cliente nuestra visión del sistema, esta vez de una forma más concreta. Dialogamos y corregimos
aquellos defectos o excesos que encontremos junto a él\footnote{%
    Puede que existan cambios de requisitos por parte de nuestro cliente. Muchas veces se
    apela a la continua transformación del entorno, pero también hay otros factores que influyen.
    Como el que, al igual que según nosotros vamos desarrollando el proyecto vamos entendiéndolo
    mejor, a nuestro cliente le pasa igual.
}.

Los requisitos que definimos probablemente no serán definitivos. Comunicamos al cliente nuestra
capacidad para cambiar un requisito según el tipo y que el coste de cambiarlos, cuanto más
avanzado esté el desarrollo, será muy superior\footnote{%
Tanto coste de tiempo, de dinero, como de oportunidad. Por ejemplo, \cite{CodeComplete2} habla
acerca de la evolución de estos costes.%
}.

\subsection{Criterios para aceptar la definición de un requisito}

Para facilitar el trabajo en la fase de construcción, tanto para los requisitos
funcionales como para los no funcionales, establecemos los siguientes criterios
para aceptar la definición de un requisito. Seguimos las recomendaciones de
\cite[Checklist: Requirements]{CodeComplete2}.

\begin{itemize}
    \item Es comprobable. A partir de una prueba debemos podemos comprobar
          que el requisito está o no satisfecho.
    \item Especifica la certeza de que vaya o no a modificarse.
    \item Tiene que ser relevante al problema y a su solución.
    \item Se expresa en términos del usuario, máquina, etc. según corresponda.
\end{itemize}

\subsection{Requisitos funcionales}

Un requisito funcional determina qué debe de hacer un sistema informático en unas determinadas circunstancias.

Siguiendo las recomendaciones de \cite[Checklist: Requirements]{CodeComplete2} establecemos
los siguientes requisitos para aceptar un requisito funcional.

\begin{itemize}
    \item Si desconocemos algún aspecto, lo explicitamos.
    \item Las salidas y las entradas deben estar especificadas.
    \item Si corresponde, las interfaces software y hardware deben
          estar especificadas.
    \item Si corresponde, los mecanismos de comunicación deben estar
          especificados.
\end{itemize}

\subsection{Requisitos no funcionales}

Un requisito no funcional determina cómo debe de actuar un sistema informático ante un estímulo en unas determinadas circunstancias.

Siguiendo las recomendaciones de \cite[Checklist: Requirements]{CodeComplete2} establecemos
los siguientes requisitos para aceptar un requisito no funcional. 

\begin{itemize}
    \item Si desconocemos algún aspecto, lo explicitamos.
    \item El tiempo de respuesta del sistema ante el usuario debe estar especificado.
    \item El nivel de seguridad debe quedar especificado.
    \item La fiabilidad dado un fallo (estrategias para detectar errores, recuperar información. etc.) debe estar especificada.
    \item Si corresponde, los requisitos de memoria y de almacenamiento persistente deben quedar especificados.
\end{itemize}

\section{Elección de arquitectura}

% La arquitectura restringirá muchos aspectos de nuestro proyecto. El hardware
% sobre el que se ejecutará, el lenguaje de programación que utilizará y sus
% herramientas disponibles (frameworks de testeo, depuración, generación de compilados,
% capacidad para proteger la propiedad intelectual), si es un sistema distribuido
% o si está en un único sitio, sin es una conjunción de librerías o es un único
% ejecutable, etc.

\subsection{Métodos para asegurar la validez de los planos}

\subsubsection{Desglose}

\subsubsection{Validación de premisas}

% A veces desconocemos si una solución va a ser efectiva
% A veces podemos probar las premisas de una solución de una forma
% menos costosa que desarrollar la solución
% Premisas OK no implican buena solución. Premisas malas implican mala solución.
% Tener en cuenta que tenemos que identificar las premisas correctamente.

%\subsubsection{¿Qué más?}

\section{Implementación: desarrollo software}

Para llevar a cabo este producto software intentaremos seguir algunas
pautas que buscarán acortar nuestros tiempos de \textit{feedback}\footnote{%
    Aunque sin acortar \textit{todos} los tiempos de \textit{feedback}. Muchas son las
    veces en que nos interesa no recibir esa realimentación porque provocaría
    algún cambio no deseado en el ámbito que queremos influir. Nos referimos
    principalmente a métodos que ayudan a descubrir defectos en el producto
    \textit{software} lo antes posible, de forma que no afecten en el ámbito en el que
    queremos influir con nuestro producto.
}.

\subsection{Entrega continua}

\subsubsection{\textit{Trunk Based Development}}

\subsection{\textit{Test Driven Development}}

% Qué es

% Por qué (simplificación del diseño, requerimientos como código)

% Cuándo utilizarlo y cuándo no (código demasiado desacoplado, puede aumentar
% complejidad en casos en los que no es necesario testar comportamiento, nivel
% de rigurosidad)

\subsection{¿Por qué acortar los tiempos de \textit{feedback}?}

\textbf{Cuanto antes detectamos que nos estamos equivocando
antes podremos corregirlo}, y antes podremos seguir adelante.

Pensemos en la situación de un enamorado sin experiencia que durante meses dedica su
tiempo, su energía y su creatividad a componerle una canción a una chica.
Durante este tiempo, este individuo mejora de forma objetiva la
melodía, letra y sensaciones que la canción genera en sí mismo
y en sus amistades. Ahora es un mejor compositor, tiene un mejor manejo
de los instrumentos que utiliza e incluso ha mejorado su
relación con sus amigos y su familia.

El chico piensa que así puede despertar o avivar un sentimiento recíproco
en la chica. Sin embargo, cuando se presenta la canción,
la realidad se impone. Entre otros muchos factores,
la falta de sincronización entre los sentimientos de ella y de él causan
de forma instintiva un rechazo en ella.

\textbf{Esta analogía ejemplifica lo absurdas e idealistas
que son estas situaciones que se dan en otros campos de nuestra vida.}
Productos excelentes desde un punto de vista técnico que se
congelan porque no se discutió un precio objetivo con
el cliente en una fase temprana del desarrollo, ideas felices
por parte de \textit{stakeholders} sobre qué debe de
ser capaz de hacer el software que terminan en años de desarrollo
y con objetivos sin cumplir, etc.

Si el chico le hubiese propuesto de quedar de una forma casual
habría llegado a conocerla mejor\footnote{¡O no! A lo mejor ella no
quiera quedar con él. Al chico le interesa
conocer esta realidad lo antes posible.}. Podría haberse dado cuenta que
ella no está acostumbrada a salir mucho de casa, que buscando sitios
interesantes con los que pasar tiempo con ella tal vez podría ganar su
confianza, y su cariño. Podría haber probado esta hipótesis, y cambiar
su estrategia según el \textit{feedback} que recibiría. Podría en este tiempo que
pasan juntos darse cuenta que no es la chica adecuada para él. Podría
incluso haberse dado cuenta que, la idea de la canción, podría ser buena
bajo unas determinadas circunstancias.

Los autores de \cite{accelerate} divulgan cómo afectan los tiempos de feedback
a los productos software. Nos centramos en los capítulos dedicados al impacto de
la entrega continua y al impacto de la entrega continua%
\footnote{%
Superconjunto de la integración continua. Básicamente consiste en la automatización
del proceso de desarrollo. \cite{ModernSoftwareEngineering} y \cite{minimumViableCD}
son buenos recursos para aprender más acerca de estos conceptos.%
}%
en la calidad. Según escriben, \textbf{existe una correlación estadística alta entre aquellos
equipos capaces de desplegar a producción a demanda y 
con mecanismos que ofrecen de forma clara un \textit{feedback} rápido en
la calidad y en la capacidad del software de desplegarse y entre el rendimiento del
equipo.}

El equipo DORA\footnote{DevOps Research and Assessment.} coincide en estos resultados.
En su publicación \cite{EliteDevOps} explican cuatro métricas que pueden medir el
rendimiento de una organización. Según explican en la entrada de blog citada,
la frecuencia de despliegue, el tiempo que tarda un commit desde que se sube
al servidor hasta que se lleva a producción,
el porcentaje de despliegues que causan un error en producción y el tiempo
que tarda una organización en recuperarse de un error son clave \textbf{para medir la
velocidad y la estabilidad en el desarrollo}.

\subsubsection{Productos para disminuir el tiempo de realimentación}

\begin{enumerate}
    \item \textbf{Automatización de los procesos de desarrollo y despliegue de la solución}, como es
    la generación de documentación, la ejecución de pruebas, la generación de librerías
    y el despliegue en la plataforma hardware, \textbf{de forma que minimicemos el tiempo de \textit{feedback}}
    una vez realicemos un cambio y \textbf{de forma que tengamos una única fuente de verdad} acerca de cómo
    validar y cómo desplegar.
\end{enumerate}

\subsection{Productos para mejorar la calidad del producto}

\begin{enumerate}
    \item \textbf{Pruebas software unitarias para cada funcionalidad implementada} que aseguren que no
    puedan ocurrir situaciones inesperadas en tiempo
    de ejecución que puedan comprometer la integridad del código de control, que se ejecutará sobre
    la misma plataforma hardware.
    \item \textbf{Documentación adecuada para que cualquier desarrollador pueda entender,
    mantener y ampliar este proyecto} en el futuro, de forma que maximicemos el atractivo
    del proyecto y de forma que minimicemos la frustración de un contribuyente potencial
    al proyecto de software libre.
\end{enumerate}

\section{Planificación del desarrollo}

% Cuánto tiempo dedicamos a cada sección.

\section{Estimación de costes}

% Desglose como piedra angular
% Uso de datos pasados
% Coste de oportunidad, recurrencia de soporte del proyecto

\section{Seguimiento del desarrollo por parte del cliente}

% Por qué
% Commits en git
% Plan de Desarrollo
% Changelog

\section{Seguimiento del coste y tiempo dedicado al proyecto}

% Por qué

% Excel de horas dedicadas
% Excel de costes asociados al proyecto
